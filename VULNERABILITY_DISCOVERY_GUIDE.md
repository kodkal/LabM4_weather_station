# üîç Security Assessment Lab Guide
## Finding and Fixing Vulnerabilities in IoT Systems

---

## Lab Overview

Your task is to perform a comprehensive security assessment of a weather station application. This version contains security vulnerabilities that are commonly found in real IoT devices. Your goal is to:

1. **Discover** security vulnerabilities
2. **Exploit** them in a controlled environment (ethically!)
3. **Document** your findings
4. **Fix** the vulnerabilities
5. **Test** your fixes

---

## ‚ö†Ô∏è Ethical Guidelines

Before starting, you must understand and agree to:

1. **Only test systems you have permission to test**
2. **Never exploit vulnerabilities in production systems**
3. **Practice responsible disclosure**
4. **Document findings professionally**
5. **Focus on learning, not causing harm**

**This lab uses an intentionally vulnerable application for educational purposes only.**

---

## Phase 1: Reconnaissance (Week 1)

### 1.1 Information Gathering

Start by understanding the application:

```bash
# Run the application
python vulnerable_weather_station.py

# Check what ports are open
netstat -tuln | grep LISTEN

# Examine the source code structure
find . -name "*.py" | head -20

# Look for interesting files
ls -la
cat requirements.txt
```

**Questions to Consider:**
- What technologies are being used?
- What endpoints are available?
- What kind of data does it handle?
- How is authentication implemented?

### 1.2 Manual Exploration

Use curl or a browser to explore:

```bash
# Test the API endpoints
curl http://localhost:8080/api/data
curl http://localhost:8080/api/login
curl http://localhost:8080/api/config

# Check response headers
curl -I http://localhost:8080/

# Look for error messages
curl http://localhost:8080/nonexistent
```

### 1.3 Code Review Checklist

Review the source code for these patterns:

- [ ] How is user input handled?
- [ ] How are SQL queries constructed?
- [ ] What encryption/hashing is used?
- [ ] How are files accessed?
- [ ] How is authentication done?
- [ ] Are there any hardcoded values?
- [ ] How are errors handled?
- [ ] What logging is implemented?

---

## Phase 2: Vulnerability Scanning (Week 1-2)

### 2.1 Static Analysis

Use automated tools to find issues:

```bash
# Install bandit for Python security linting
pip install bandit

# Run bandit on the source code
bandit -r . -f json -o bandit_report.json

# Check the report
python -m json.tool bandit_report.json | less
```

Look for:
- Use of dangerous functions
- Hardcoded passwords
- Weak cryptography
- Unsafe deserialization

### 2.2 Dependency Scanning

Check for vulnerable dependencies:

```bash
# Install safety
pip install safety

# Check dependencies
safety check --json

# Also check with pip-audit
pip install pip-audit
pip-audit
```

### 2.3 Secret Scanning

Search for exposed secrets:

```bash
# Look for common secret patterns
grep -r "password\|passwd\|pwd\|secret\|api_key\|apikey" . --include="*.py"

# Check for private keys
grep -r "BEGIN RSA PRIVATE KEY" .

# Look for tokens
grep -r "token\|jwt\|session" . --include="*.py"
```

---

## Phase 3: Web Application Testing (Week 2)

### 3.1 Authentication Testing

Test the login mechanism:

```python
# Test script for authentication
import requests

# Test 1: Normal login
response = requests.post('http://localhost:8080/api/login', 
                        json={'username': 'admin', 'password': 'test'})
print(f"Normal login: {response.status_code}")

# Test 2: SQL injection attempts
payloads = [
    {"username": "admin' --", "password": "anything"},
    {"username": "admin' OR '1'='1", "password": "anything"},
    {"username": "admin", "password": "' OR '1'='1"}
]

for payload in payloads:
    response = requests.post('http://localhost:8080/api/login', json=payload)
    print(f"Payload {payload}: {response.status_code}")
```

### 3.2 Input Validation Testing

Test how the application handles various inputs:

```python
# Test different input types
test_inputs = [
    "normal_input",
    "<script>alert('XSS')</script>",
    "../../etc/passwd",
    "'; DROP TABLE users; --",
    "$(whoami)",
    "__import__('os').system('ls')"
]

for test_input in test_inputs:
    # Test each endpoint that accepts input
    print(f"Testing: {test_input[:20]}...")
```

### 3.3 Session Management

Examine JWT tokens if used:

```python
# If you get a JWT token
import jwt

token = "eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9..."

# Try to decode without verification
try:
    decoded = jwt.decode(token, options={"verify_signature": False})
    print("Decoded token:", decoded)
except:
    print("Failed to decode")

# Check for common weak secrets
common_secrets = ['secret', 'secret123', 'password', 'jwt_secret_key']
for secret in common_secrets:
    try:
        decoded = jwt.decode(token, secret, algorithms=['HS256'])
        print(f"Token decoded with secret: {secret}")
        break
    except:
        continue
```

---

## Phase 4: Advanced Testing (Week 2-3)

### 4.1 Using OWASP ZAP

```bash
# Install OWASP ZAP
# Download from: https://www.zaproxy.org/download/

# Run automated scan
zap-cli quick-scan --self-contained \
    --start-options '-config api.disablekey=true' \
    http://localhost:8080
```

### 4.2 Using Burp Suite

1. Configure browser proxy to 127.0.0.1:8080
2. Browse the application
3. Check Proxy > HTTP history
4. Right-click requests > Send to Intruder/Repeater
5. Test different payloads

### 4.3 Command Injection Testing

```bash
# Test if commands can be executed
curl -X POST http://localhost:8080/api/command \
    -H "Content-Type: application/json" \
    -d '{"command": "id"}'

# Test command chaining
curl -X POST http://localhost:8080/api/command \
    -H "Content-Type: application/json" \
    -d '{"command": "echo test; whoami"}'
```

---

## Vulnerability Categories to Look For

### 1. Injection Vulnerabilities
- SQL Injection
- Command Injection
- Path Traversal
- XXE Injection
- LDAP Injection

### 2. Broken Authentication
- Weak passwords
- Session fixation
- Missing authentication
- Privilege escalation

### 3. Sensitive Data Exposure
- Hardcoded credentials
- Unencrypted data
- Information in logs
- Debug information

### 4. Security Misconfiguration
- Default credentials
- Unnecessary features
- Verbose errors
- Open ports

### 5. Broken Access Control
- Direct object references
- Missing authorization
- CORS misconfiguration

### 6. Cryptographic Failures
- Weak algorithms
- Poor key management
- Missing encryption
- Bad random numbers

### 7. Insecure Deserialization
- Pickle usage
- YAML unsafe loading
- JSON parsing issues

### 8. Using Components with Known Vulnerabilities
- Outdated libraries
- Unpatched dependencies

---

## Documentation Template

For each vulnerability found, document:

```markdown
## Vulnerability #X: [Title]

### Description
Brief description of the vulnerability

### Location
File: [filename]
Line: [line number]
Function: [function name]

### Severity
[Critical/High/Medium/Low]

### Proof of Concept
```
# Code or commands that demonstrate the vulnerability
```

### Impact
What can an attacker do with this vulnerability?

### Remediation
How to fix this vulnerability

### Testing
How to verify the fix works
```

---

## Hints (Use Only If Stuck!)

<details>
<summary>Hint 1: Authentication Issues</summary>

Look closely at how the login function constructs database queries. What happens if you include special characters in the username or password?

</details>

<details>
<summary>Hint 2: File Operations</summary>

When the application reads or writes files, does it validate the filename? What if you try to access files outside the intended directory?

</details>

<details>
<summary>Hint 3: Secrets Management</summary>

Search the code for hardcoded values. Are there any passwords, API keys, or secrets directly in the source code?

</details>

<details>
<summary>Hint 4: Data Serialization</summary>

How does the application save and load data? Some serialization methods can execute arbitrary code.

</details>

<details>
<summary>Hint 5: Token Security</summary>

If JWT tokens are used, decode them at jwt.io. Check the expiration time and algorithm used.

</details>

---

## Testing Your Fixes

After fixing vulnerabilities, create tests:

```python
import pytest
import requests

def test_sql_injection_fixed():
    """Verify SQL injection is prevented"""
    response = requests.post('http://localhost:8080/api/login',
        json={'username': "admin' OR '1'='1", 'password': 'test'})
    
    assert response.status_code == 401, "SQL injection still works!"

def test_path_traversal_fixed():
    """Verify path traversal is prevented"""
    response = requests.get('http://localhost:8080/api/file?name=../../../etc/passwd')
    
    assert response.status_code == 403 or response.status_code == 404
    assert 'root:' not in response.text

def test_command_injection_fixed():
    """Verify command injection is prevented"""
    response = requests.post('http://localhost:8080/api/command',
        json={'command': 'ls; cat /etc/passwd'})
    
    assert 'root:' not in response.text
```

---

## Submission Requirements

### 1. Vulnerability Report (40%)
- List all vulnerabilities found
- Include severity ratings
- Provide proof of concept for each
- Document potential impact

### 2. Fixed Code (40%)
- Submit corrected version
- Highlight what was changed
- Explain why fixes work

### 3. Test Suite (20%)
- Automated tests for each vulnerability
- Evidence that fixes work
- Performance impact assessment

---

## Tools Reference

### Essential Tools
- **Burp Suite**: Web application testing
- **OWASP ZAP**: Automated scanning
- **sqlmap**: SQL injection testing
- **Nikto**: Web server scanning
- **Wireshark**: Network analysis

### Python Libraries
```bash
pip install requests pytest bandit safety pylint black
```

### Useful Commands
```bash
# Find interesting strings
strings binary_file

# Check file permissions
ls -la

# Monitor network traffic
tcpdump -i lo -w capture.pcap

# Check running processes
ps aux | grep python

# View open files
lsof -p [process_id]
```

---

## Grading Rubric

- **Discovery (40%)**: Number and severity of vulnerabilities found
- **Analysis (20%)**: Quality of vulnerability documentation
- **Remediation (30%)**: Effectiveness of fixes
- **Testing (10%)**: Completeness of test suite

---

## Remember

1. **Think like an attacker** to find vulnerabilities
2. **Think like a defender** to fix them properly
3. **Document everything** professionally
4. **Test your fixes** thoroughly
5. **Learn from each vulnerability** you find

Good luck with your security assessment!

---

*Security Assessment Lab Guide v1.0*